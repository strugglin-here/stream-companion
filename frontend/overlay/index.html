<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Companion - Overlay</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 1920px;
            height: 1080px;
            background: transparent;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* Element container */
        .element {
            position: absolute;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }
        
        .element.visible {
            opacity: 1;
        }
        
        /* Media elements */
        .element img,
        .element video {
            display: block;
            max-width: 100%;
            height: auto;
        }
        
        .element video {
            background: transparent;
        }
        
        /* Text elements */
        .element-text {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            white-space: pre-wrap;
        }
        
        /* Placeholder for unconfigured elements (debug) */
        .element-placeholder {
            padding: 20px 30px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .element-placeholder .element-name {
            font-size: 22px;
            font-weight: bold;
        }
        
        .element-placeholder .element-info {
            font-size: 14px;
            opacity: 0.8;
        }
        
        /* Placeholder type colors (for unconfigured elements) */
        .element-placeholder[data-type="image"] {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .element-placeholder[data-type="video"] {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .element-placeholder[data-type="audio"] {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        .element-placeholder[data-type="text"] {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }
        
        .element-placeholder[data-type="timer"] {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }
        
        .element-placeholder[data-type="counter"] {
            background: linear-gradient(135deg, #30cfd0 0%, #330867 100%);
        }
        
        .element-placeholder[data-type="animation"] {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
        }
        
        .element-placeholder[data-type="canvas"] {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
        }
        
        /* Connection status indicator */
        .status-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ef4444;
            transition: background 0.3s;
            z-index: 10000;
        }
        
        .status-indicator.connected {
            background: #10b981;
        }
        
        /* Debug info (can be hidden in production) */
        .debug-info {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            font-family: monospace;
            z-index: 10000;
            display: none; /* Hidden by default, enable with ?debug=1 */
        }
        
        .debug-info.visible {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Connection status indicator -->
    <div class="status-indicator" id="statusIndicator"></div>
    
    <!-- Debug info (optional) -->
    <div class="debug-info" id="debugInfo">
        <div>Elements: <span id="elementCount">0</span></div>
        <div>Visible: <span id="visibleCount">0</span></div>
        <div>Last update: <span id="lastUpdate">-</span></div>
    </div>

    <script>
        /**
         * Stream Companion Overlay - Widget-Based Architecture
         * 
         * This overlay displays elements from the ACTIVE dashboard.
         * 
         * Loading Strategy:
         * 1. Connect to WebSocket at /ws?client_type=overlay
         * 2. Fetch active dashboard from /api/dashboards/
         * 3. For each widget on the dashboard, fetch full details from /api/widgets/{id}
         * 4. Render all elements from all widgets
         * 
         * Real-time Updates:
         * - element_update: Widget feature modified an element (show/hide/update properties)
         * - dashboard_activated: New dashboard became active (reload all elements)
         * - dashboard_deactivated: Dashboard was deactivated (clear overlay)
         * 
         * Note: Elements are NEVER accessed via a direct /api/elements endpoint.
         * They are always loaded through their owning widgets.
         */
        
        // Configuration
        const WS_URL = 'ws://localhost:8002/ws?client_type=overlay';
        const API_URL = 'http://localhost:8002/api';
        const RECONNECT_DELAY = 3000;
        
        // State
        let ws = null;
        let elements = new Map(); // element_id -> element data
        let reconnectTimeout = null;
        
        // DOM elements
        const statusIndicator = document.getElementById('statusIndicator');
        const debugInfo = document.getElementById('debugInfo');
        
        // Enable debug mode with ?debug=1
        if (window.location.search.includes('debug=1')) {
            debugInfo.classList.add('visible');
        }
        
        // WebSocket connection
        function connect() {
            console.log('Connecting to WebSocket...');
            ws = new WebSocket(WS_URL);
            
            ws.onopen = () => {
                console.log('âœ“ WebSocket connected');
                statusIndicator.classList.add('connected');
                
                // Load elements from active dashboard
                loadElements();
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleMessage(data);
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
            
            ws.onclose = () => {
                console.log('WebSocket disconnected');
                statusIndicator.classList.remove('connected');
                
                // Attempt to reconnect
                reconnectTimeout = setTimeout(connect, RECONNECT_DELAY);
            };
        }
        
        // Handle WebSocket messages
        function handleMessage(data) {
            console.log('Received message:', data);
            updateDebugInfo();
            
            switch (data.type) {
                case 'connection':
                    console.log('Connection confirmed:', data.message);
                    break;
                    
                case 'element_update':
                    handleElementUpdate(data);
                    break;
                    
                case 'dashboard_activated':
                    console.log('Dashboard activated:', data.dashboard_id);
                    // Remove 'no dashboard' message if present
                    removeNoDashboardMessage();
                    // Reload elements from new active dashboard
                    loadElements();
                    break;
                    
                case 'dashboard_deactivated':
                    console.log('Dashboard deactivated:', data.dashboard_id);
                    // Hide all elements (new dashboard will be activated)
                    elements.forEach((element, id) => {
                        removeElement(id);
                    });
                    break;
                    
                case 'pong':
                    // Keepalive response
                    break;
                    
                default:
                    console.log('Unknown message type:', data.type);
            }
        }
        
        // Handle element updates
        function handleElementUpdate(data) {
            const { action, element, element_id } = data;
            
            switch (action) {
                case 'create':
                case 'update':
                case 'show':
                case 'hide':
                    if (element) {
                        elements.set(element.id, element);
                        renderElement(element);
                    }
                    break;
                    
                case 'delete':
                    // Use element_id since element object may be null for deletes
                    if (element_id) {
                        removeElement(element_id);
                    }
                    break;
            }
            
            updateDebugInfo();
        }
        
        // Load initial elements from active dashboard
        async function loadElements() {
            try {
                // First, get all dashboards to find the active one
                const dashboardsResponse = await fetch(`${API_URL}/dashboards/`);
                const dashboardsData = await dashboardsResponse.json();
                
                // Find active dashboard
                const activeDashboard = dashboardsData.dashboards.find(d => d.is_active);
                
                if (!activeDashboard) {
                    console.log('No active dashboard - overlay is empty');
                    showNoDashboardMessage();
                    return;
                }
                
                console.log(`Active dashboard: ${activeDashboard.name} (ID: ${activeDashboard.id})`);
                
                // Get full dashboard details with widgets
                const dashboardResponse = await fetch(`${API_URL}/dashboards/${activeDashboard.id}`);
                const dashboard = await dashboardResponse.json();
                
                // Clear existing elements
                elements.clear();
                document.querySelectorAll('.element').forEach(el => el.remove());
                
                // Load widgets and their elements
                let elementCount = 0;
                for (const widgetSummary of dashboard.widgets) {
                    // Get full widget details with elements
                    const widgetResponse = await fetch(`${API_URL}/widgets/${widgetSummary.id}`);
                    const widget = await widgetResponse.json();
                    
                    console.log(`Loading widget: ${widget.name} (${widget.widget_class})`);
                    
                    // Render each element from this widget
                    widget.elements.forEach(element => {
                        elements.set(element.id, element);
                        renderElement(element);
                        elementCount++;
                    });
                }
                
                console.log(`Loaded ${elementCount} elements from ${dashboard.widgets.length} widgets`);
                updateDebugInfo();
            } catch (error) {
                console.error('Failed to load elements:', error);
            }
        }
        
        // Render or update an element in the DOM
        function renderElement(element) {
            let elementDiv = document.getElementById(`element-${element.id}`);
            
            // If element exists and type changed, remove and recreate
            if (elementDiv && elementDiv.getAttribute('data-type') !== element.element_type) {
                removeElement(element.id);
                elementDiv = null;
            }
            
            // Create element if it doesn't exist
            if (!elementDiv) {
                elementDiv = createElementDOM(element);
                document.body.appendChild(elementDiv);
            } else {
                // Update existing element
                updateElementDOM(elementDiv, element);
            }
            
            // Apply properties (position, size, opacity, CSS)
            applyElementProperties(elementDiv, element);
            
            // Handle visibility with transition
            if (element.visible) {
                setTimeout(() => {
                    elementDiv.classList.add('visible');
                    // If it's audio and autoplay is true, play it
                    if (element.element_type.toLowerCase() === 'audio') {
                        const audio = elementDiv.querySelector('audio');
                        if (audio && element.properties?.autoplay !== false) {
                            audio.play().catch(err => console.log('Audio play failed:', err));
                        }
                    }
                }, 10);
            } else {
                elementDiv.classList.remove('visible');
                // If it's audio or video, stop playback when hiding
                const media = elementDiv.querySelector('audio, video');
                if (media) {
                    media.pause();
                    media.currentTime = 0;
                }
            }
        }
        
        // Create DOM element based on element type
        function createElementDOM(element) {
            const container = document.createElement('div');
            container.id = `element-${element.id}`;
            container.className = 'element';
            container.setAttribute('data-type', element.element_type);
            
            // Create appropriate content based on type
            const content = createElementContent(element);
            if (content) {
                container.appendChild(content);
            }
            
            return container;
        }
        
        // Create actual media/content element
        function createElementContent(element) {
            const type = element.element_type.toLowerCase();
            
            switch (type) {
                case 'image':
                    return createImageElement(element);
                    
                case 'video':
                    return createVideoElement(element);
                    
                case 'audio':
                    return createAudioElement(element);
                    
                case 'text':
                    return createTextElement(element);
                    
                case 'timer':
                case 'counter':
                case 'animation':
                case 'canvas':
                    // TODO: Implement these element types
                    return createPlaceholderElement(element);
                    
                default:
                    return createPlaceholderElement(element);
            }
        }
        
        // Create image element
        function createImageElement(element) {
            if (!element.asset_path) {
                return createPlaceholderElement(element);
            }
            
            const img = document.createElement('img');
            img.src = element.asset_path;
            img.alt = element.name;
            
            // Handle load error
            img.onerror = () => {
                console.error(`Failed to load image: ${element.asset_path}`);
                img.style.display = 'none';
            };
            
            return img;
        }
        
        // Create video element
        function createVideoElement(element) {
            if (!element.asset_path) {
                return createPlaceholderElement(element);
            }
            
            const video = document.createElement('video');
            video.src = element.asset_path;
            
            // Apply video properties from element.properties
            const props = element.properties || {};
            video.autoplay = props.autoplay !== false; // Default true
            video.loop = props.loop || false;
            video.muted = props.muted || false;
            video.controls = props.controls || false;
            
            // Handle load error
            video.onerror = () => {
                console.error(`Failed to load video: ${element.asset_path}`);
                video.style.display = 'none';
            };
            
            return video;
        }
        
        // Create audio element
        function createAudioElement(element) {
            if (!element.asset_path) {
                return createPlaceholderElement(element);
            }
            
            const audio = document.createElement('audio');
            audio.src = element.asset_path;
            
            // Apply audio properties from element.properties
            const props = element.properties || {};
            audio.autoplay = props.autoplay !== false; // Default true
            audio.loop = props.loop || false;
            audio.volume = props.volume !== undefined ? props.volume : 1.0;
            
            // Store reference for control via features
            audio.dataset.elementId = element.id;
            
            // Handle load error
            audio.onerror = () => {
                console.error(`Failed to load audio: ${element.asset_path}`);
            };
            
            // Audio elements are invisible but need to be in DOM to play
            audio.style.display = 'none';
            
            return audio;
        }
        
        // Create text element
        function createTextElement(element) {
            const textDiv = document.createElement('div');
            textDiv.className = 'element-text';
            
            const props = element.properties || {};
            textDiv.textContent = props.text || element.name;
            
            // Apply text styling from properties
            if (props.fontSize) textDiv.style.fontSize = props.fontSize;
            if (props.fontFamily) textDiv.style.fontFamily = props.fontFamily;
            if (props.color) textDiv.style.color = props.color;
            if (props.textAlign) textDiv.style.textAlign = props.textAlign;
            if (props.fontWeight) textDiv.style.fontWeight = props.fontWeight;
            
            return textDiv;
        }
        
        // Create placeholder for unconfigured/unsupported elements
        function createPlaceholderElement(element) {
            const placeholder = document.createElement('div');
            placeholder.className = 'element-placeholder';
            placeholder.setAttribute('data-type', element.element_type);
            
            const displayType = element.element_type.toUpperCase();
            const assetStatus = element.asset_path 
                ? `Asset: ${element.asset_path}` 
                : 'No asset configured';
            
            placeholder.innerHTML = `
                <div class="element-name">${element.name}</div>
                <div class="element-info">${displayType}</div>
                <div class="element-info" style="font-size: 12px; opacity: 0.6;">${assetStatus}</div>
            `;
            
            return placeholder;
        }
        
        // Update existing element DOM
        function updateElementDOM(elementDiv, element) {
            const type = element.element_type.toLowerCase();
            
            // Update content based on type
            switch (type) {
                case 'image':
                    const img = elementDiv.querySelector('img');
                    if (img && element.asset_path) {
                        img.src = element.asset_path;
                    }
                    break;
                    
                case 'video':
                    const video = elementDiv.querySelector('video');
                    if (video && element.asset_path) {
                        video.src = element.asset_path;
                        const props = element.properties || {};
                        video.muted = props.muted || false;
                        video.loop = props.loop || false;
                    }
                    break;
                    
                case 'audio':
                    const audio = elementDiv.querySelector('audio');
                    if (audio && element.asset_path) {
                        audio.src = element.asset_path;
                        const props = element.properties || {};
                        audio.volume = props.volume !== undefined ? props.volume : 1.0;
                        audio.loop = props.loop || false;
                    }
                    break;
                    
                case 'text':
                    const textDiv = elementDiv.querySelector('.element-text');
                    if (textDiv) {
                        const props = element.properties || {};
                        textDiv.textContent = props.text || element.name;
                        if (props.fontSize) textDiv.style.fontSize = props.fontSize;
                        if (props.color) textDiv.style.color = props.color;
                    }
                    break;
            }
        }
        
        // Apply element properties (position, size, opacity, CSS)
        function applyElementProperties(elementDiv, element) {
            const props = element.properties || {};
            
            // Position (default to grid if not specified)
            const position = props.position || getGridPosition(element.id);
            if (position.x !== undefined) {
                elementDiv.style.left = typeof position.x === 'number' ? `${position.x}px` : position.x;
            }
            if (position.y !== undefined) {
                elementDiv.style.top = typeof position.y === 'number' ? `${position.y}px` : position.y;
            }
            if (position.z_index !== undefined) {
                elementDiv.style.zIndex = position.z_index;
            }
            
            // Size
            if (props.size) {
                if (props.size.width !== undefined) {
                    elementDiv.style.width = typeof props.size.width === 'number' 
                        ? `${props.size.width}px` 
                        : props.size.width;
                }
                if (props.size.height !== undefined) {
                    elementDiv.style.height = typeof props.size.height === 'number' 
                        ? `${props.size.height}px` 
                        : props.size.height;
                }
            }
            
            // Opacity
            if (props.opacity !== undefined) {
                // Opacity is applied via visible class, but can be overridden
                elementDiv.style.setProperty('--element-opacity', props.opacity);
            }
            
            // Custom CSS
            if (props.css) {
                Object.assign(elementDiv.style, props.css);
            }
            
            // Transform (for animations via behavior)
            if (props.transform) {
                elementDiv.style.transform = props.transform;
            }
        }
        
        // Remove an element from the DOM
        function removeElement(elementId) {
            const elementDiv = document.getElementById(`element-${elementId}`);
            if (elementDiv) {
                elementDiv.classList.remove('visible');
                setTimeout(() => {
                    elementDiv.remove();
                    elements.delete(elementId);
                    updateDebugInfo();
                }, 300); // Wait for fade-out animation
            }
        }
        
        // Simple grid positioning for elements without custom positions
        function getGridPosition(elementId) {
            const col = (elementId - 1) % 4;
            const row = Math.floor((elementId - 1) / 4);
            return {
                x: `${col * 400 + 100}px`,
                y: `${row * 200 + 100}px`
            };
        }
        
        // Show message when no dashboard is active
        function showNoDashboardMessage() {
            removeNoDashboardMessage(); // Remove any existing
            const message = document.createElement('div');
            message.id = 'no-dashboard-message';
            message.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 30px 50px;
                border-radius: 12px;
                font-size: 24px;
                font-weight: bold;
                text-align: center;
                z-index: 10000;
            `;
            message.textContent = 'Waiting for dashboard activation...';
            document.body.appendChild(message);
        }
        
        // Remove 'no dashboard' message
        function removeNoDashboardMessage() {
            const message = document.getElementById('no-dashboard-message');
            if (message) {
                message.remove();
            }
        }
        
        // Update debug info
        function updateDebugInfo() {
            if (!debugInfo.classList.contains('visible')) return;
            
            const visibleCount = Array.from(elements.values())
                .filter(el => el.visible).length;
            
            document.getElementById('elementCount').textContent = elements.size;
            document.getElementById('visibleCount').textContent = visibleCount;
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }
        
        // Send keepalive ping every 30 seconds
        setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'ping' }));
            }
        }, 30000);
        
        // Initialize
        connect();
        
        // Cleanup on unload
        window.addEventListener('beforeunload', () => {
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
            }
            if (ws) {
                ws.close();
            }
        });
    </script>
</body>
</html>
